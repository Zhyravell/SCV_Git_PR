![Logo](27.jpg)
# **Работа с Git и gitHub**

## 1. Проверка наличия установленного Git
в терминале выполнить команду `git --version`
Если Git установлен, появится сообщение с информацией о версии программы, иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git с сайта https://git-scm.com/downloads.
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git
При первом использовании необходимо представиться. Для этого необходимо ввести в терминале 2 команды:
```
git config --global user.name "Ваше имя"
git config --global user.email "ваша почта@example.com"

```Python
while n < 0:
     n++
```
## 4. Инициализация репозитория
Для инициализации нового репозитория .git подойдёт git init или, чтобы скопировать существующий, git clone <адрес репозитория>.
## 5. Запись изменений в репозиторий

### Команда git status: 
отображает все файлы, которые различаются между тремя разделами. У файлов есть 4 состояния:

* Неотслеживаемый (untracked) — находится в рабочей директории, но нет ни одной версии в HEAD или в области подготовленных файлов (Git не знает о файле).
* Изменён (modified) — в рабочей директории есть более новая версия по сравнению с хранящейся в HEAD или в области подготовленных файлов (изменения не находятся в следующем коммите).
* Подготовлен (staged) — в рабочей директории и области подготовленных файлов есть более новая версия по сравнению с хранящейся в HEAD (готов к коммиту).
* Без изменений — одна версия файла во всех разделах, т. е. в последнем коммите содержится актуальная версия.
### git commit:

Основы работы с Git предполагают понимание коммитов. Команда git commit откроет текстовый редактор для ввода сообщения коммита. Также эта команда принимает несколько аргументов:

* -m позволяет написать сообщение вместе с командой, не открывая редактор. Например git commit -m "Пофиксил баг";
* -a переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом);
* --amend заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.

### git add:

Команда git add <файл/папка> обновляет область подготовленных файлов версиями файлов/папок из рабочей директории.

## 6. Просмотр истории коммитов

### git log:
Для просмотра истории предыдущих коммитов в обратном хронологическом порядке можно использовать команду git log. Ей можно передать разные опции:

* -p показывает изменения в каждом коммите;
* --stat показывает сокращённую статистику для коммитов, например изменённые файлы и количество добавленных/удалённых строк в каждом их них;
* -n показывает n последних коммитов;
* --since=___ и --until=___ позволяет отфильтровать коммиты по промежутку времени, например --since="2019-01-01" покажет коммиты с 1 января 2019 года;
* --pretty позволяет указать формат логов (например, --pretty=oneline), также можно использовать --pretty=format для большей кастомизации, например --pretty=format:"%h %s";
* --grep и -S фильтруют коммиты с сообщениями/изменениями кода, которые содержат указанную строку, например, git log -S имя_функции позволяет посмотреть добавление/удаление функции;
* --no-merges пропускает коммиты со слиянием веток;

### git diff:

Чтобы посмотреть сами изменения, а не изменённые файлы, можно использовать следующие команды:

* git diff — сравнение рабочей директории с областью подготовленных файлов;
* git diff --staged — сравнение области подготовленных файлов с HEAD.
Если использовать аргумент <файл/папка>, то diff покажет изменения только для указанных файлов/папок, например git diff src/.

## 7. Перемещение между сохранениями

### git checkout:

Команда git checkout HEAD <файл> приводит к тому же результату, что и git reset --hard HEAD <файл> — перезаписывает версию файла в области подготовленных файлов и в рабочей директорией версией из HEAD, то есть отменяет изменения после последнего коммита.

С другой стороны, git checkout <файл> (уже без HEAD) перезаписывает версию файла в рабочей директории версией в области подготовленных файлов, то есть отменяет изменения с момента последней подготовленной версии.
git checkout master позволяет вернуться к актуальному состоянию и продолжить работу

## 8. Игнорирование файлов

Для того чтобы исключить из отслеживания в репозитории определенные файлы и папки, необходимо создать файл ***.gitignore*** и записать в него их названия или шаблоны, соотвтствующие таким файлам или папкам.

## 9. Создание веток в Git

По умолчанию, имя основной ветки в git - *master*.
Создать ветку можно командой:
~~~
git branch "имя ветки"
~~~
Список веток в репозитории можно просмотреть с помощью команды 
~~~
git branch
~~~
Текущая ветка будет отмечена звездочкой: **\*master**
## 10. Cлияние веток

Для слияния текущей ветки с какой-либо другой используется команда git merge "имя_ветки" В результате выполнения этой команды в текущей ветке появится новый коммит. Этот коммит будет иметь два предка – последние коммиты обоих веток, участвующих в слиянии.
* --abort
Ключ, использующийся только при разрешении конфликтов. Позволяет прервать слияние и вернуть все к моменту начала операции.

## 11. Разрешение конфликтов
Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. 
Конфликт во время слияния может произойти в двух отдельных точках — при запуске и во время процесса слияния.
Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд git stash, git checkout, git commit или git reset.
Сбой В ПРОЦЕССЕ слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. Git сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы можно было разрешить их вручную.
Самый простой способ разрешить конфликт — отредактировать конфликтующий файл, выбрав один из трех предложенных  гитом вариантов, а именно выбор текущего изменения, изменения в ветке с которой происходит слияние, или сохранение обоих вариантов (объединение).
После разрешения конфликта необходимо произвести вышеуказанный коммит слияния.
## 12. Удаление веток
Для удаления веток используются команды *git branch* с ключами -d и -D.
-d
--delete
С этим ключом команда удалит вашу ветку. Ветка будет удалена только в том случае, если она полностью слита с одной из других веток. В противном случае, Git выдаст предупреждение, о том, что в ветке есть неслитые изменения, и не даст ее удалить.

-D
Этот ключ нужен, если вы хотите удалить ветку, игнорируя предупреждения Git. В отличие от -d, этот ключ удалит ветку в любом случае, даже если в ней есть изменения, которые вы можете потерять.
если нужно удалить текущую ветку, то сначала нужно переключиться на какую-либо другую ветку, а только потом выполнять удаление.

## 13. Работа с репозиторием

* Для того чтобы связать удалённый и локальный репозитории используется команда
~~~
 git remote add origin [ссылка на удалённый репозиторий]
~~~
Origin - имя удаленного репозитория в команде (можете придумать сами). Впоследствии, при работе с этим удаленным репозиторием, вы будете обращаться к нему по придуманному имени.
Ссылку на удаленный репозиторий можно взять, нажав на большую зеленую кнопку Code на странице репозитория на GitHub.
* Для того чтобы подтянуть изменения необходима команда
```
git pull
```
Она подтягивает в локальный репозиторий последнюю версию проекта. При этом вызов этой команды сотрёт все незафиксированные изменения. Также следует обратить внимание и на то, что после ввода этой команды может появиться конфликт. Команда git pull это просто сокращение последовательного применения git fetch и git merge. Но используется git pull намного чаще.
* Чтобы склонировать удалённый репозиторий используем
```
git clone [ссылка на удалённый репозиторий]
```
Проект появится в директории, где вы находились в момент клонирования.
* Запушить изменения возможно с помощью команды
```
git push
```
Она отправляет все зафиксированные изменения с локального репозитория в удалённый. 

## 14. pull request and fork
pull request — предложение изменения кода в чужом репозитории.
Вы делаете fork (опишу ниже) чужого репозитория (который иногда и сам может быть форком), затем производите изменения в своём форке посредством *pull request* предлагаете изменения владельцам репозитория, чей fork Вы сделали. На GitHub *pull request* в публичный репозиторий может осуществить любой зарегистрированный участник.
Fork – точная копия чужого репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.
Если коротко, форки и пулл-реквесты нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на GitHub. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей.
git remote git pull git push pull request fork